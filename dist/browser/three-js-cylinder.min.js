!(function(t, i) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = i(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], i)
: (t.THREECylinder = i(t.THREE));
})(this, function(t) {
"use strict";
(t = t && t.hasOwnProperty("default") ? t.default : t).Box3, t.Vector3;
function i(i, s, e, n, r) {
(this.v = i || new t.Vector3()),
(this.axis = s || new t.Vector3(1, 0, 0)),
(this.radius = e),
(this.inf = n || 0),
(this.sup = r || 1 / 0);
}
var s, e, n, r;
return (
Object.assign(i.prototype, {
set: function(t, i, s, e, n) {
return (
this.v.copy(t),
this.axis.copy(i),
(this.radius = s),
(this.inf = e || 0),
(this.sup = n || 1 / 0),
this
);
},
clone: function() {
return new this.constructor().copy(this);
},
copy: function(t) {
return (
this.v.copy(t.v),
this.axis.copy(t.axis),
(this.radius = t.radius),
(this.inf = t.inf),
(this.sup = t.sup),
this
);
},
empty: function() {
return this.radius <= 0 || this.inf >= this.sup;
},
getBoundingBox: function(t) {
throw "not implemented yet, todo";
},
equals: function(t) {
return (
t.v.equals(this.v) &&
t.axis.equals(this.axis) &&
t.radius === this.radius &&
t.inf === this.inf &&
t.sup === this.sup
);
}
}),
(t.Cylinder = i),
(t.Ray.prototype.intersectCylinder =
((s = new t.Vector3()),
(e = new t.Vector3()),
(n = new t.Vector3()),
(r = new t.Vector3()),
function(t, i) {
s.subVectors(this.origin, t.v);
var o = s.dot(t.axis),
u = this.direction.dot(t.axis);
n.set(
this.direction.x - u * t.axis.x,
this.direction.y - u * t.axis.y,
this.direction.z - u * t.axis.z
),
r.set(s.x - o * t.axis.x, s.y - o * t.axis.y, s.z - o * t.axis.z);
var a = n.lengthSq(),
h = 2 * n.dot(r),
c = h * h - 4 * a * (r.lengthSq() - t.radius * t.radius);
if (c < 0) return null;
if (0 === c) {
var d = (-h - Math.sqrt(c)) / (2 * a);
this.at(d, i), e.subVectors(i, t.v);
var f = e.dot(t.axis);
return d > 0 && f > t.inf && f < t.sup ? i : null;
}
var p = Math.sqrt(c);
(d = (-h - p) / (2 * a)),
this.at(d, i),
e.subVectors(i, t.v),
(f = e.dot(t.axis)),
(d < 0 || f < t.inf || f > t.sup) && (d = Number.MAX_VALUE);
var x = (-h + p) / (2 * a);
return (
this.at(x, r),
e.subVectors(r, t.v),
(f = e.dot(t.axis)),
x > 0 && f > t.inf && f < t.sup && x < d && ((d = x), i.copy(r)),
d !== Number.MAX_VALUE ? i : null
);
})),
i
);
});
